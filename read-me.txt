Ну вот мы и дошли до react. Ухуууу.
В общем материала настолько будет много, что я решил его вынести в отдельную папку с репозиторием 
Также подумываю перенести все конспекты в notion, чтобы поцветастее было, да понятнее и удобнее. Но это как нибудь потом

Итак, начнем. React что щас, что и дальше будет популярным и постоянно всплывать в вакансиях. Как и говорилось ранее React
это целая среда и экосистема разработки у которой даже есть свои фреймворки и библиотеки. То есть у библиотеки есть свои библиотеки
ВОт настолько все зашло. 
React обычно предназначен для создания одностраничных приложений. То есть когда только какие-то част сайта обновляются, но не целая страница
Примепрами singlepage app является gmail instagram facebook. 
Основными принципами react или лучше сказать философией react является декларативность. То есть когда вы задаете просто конечную цель с результатом,
а не прописываете шаги к ней. Также создание своих компонентов. То есть браузеру придется не одно огромное дом дерево обрабатывать, где у каждого элемента по тысячи свойств,
а всего лишь скромные, ну или не скромные компоненты, созданные react и вами. Ну и что еще хочу выделить из принципов, так это то что эти компоненты будет легко использовать
повторно, хоть в других проектах.

Итак, переходим к подключению. Во-первых просто добавить реакт как например jquery или bootstrap не получится. Надо создаватьдля этого отдельный проект
Во-вторых, react уже имеет в себе некий webpack, который будет объединять модули, а также babel, который выступает в роли кроссбраузерности и компилятора.
Так как же мать его уже приступить к работе?
Щас все будет, не ссыте. Чтобы не создавать тысячу папок, за вас уже сделали готовую сборку для старта проекта

Запускаем эту команду:
npx create-react-app my-app

Когда все утсановится, вы увидите папку с my app и вам предложат перейти в эту папку, поэтомк не будем спорить и сделаем это
прописываем:
cd my-app

Теперь мы видим, что по путям мы зашли в папку. Также нам предлагают запустить это приложение, но щас пройдемся по папкам
Итак, в папке src мы видим index.js Помним, что это самый главный файл, то есть в этот файл все импортируется и именно этот файл будет обрабатывать браузер
Также, видим и другие всякие папки. Интуитивно можно догадаться, но в дальнейшем все разберем
Переходим в папку public. Там находятся все файлы, которые мы не будем особо трогать. Например, мы видим index.html. Логично что именно он будет отображаться. Щас в нем прописаны теги, чтобы при запуске у нас не было пустое окно
Также видим div с id='root'. Именно туда будет все рендерится
Еще если мы перейдем в package-json, то увидим все библиотеки, которые подрублены. Да, по факту мы щас не только react установили. Но не волнуйтесь, скоро со всем разберемся
Так вот, там мы можем увидеть eslint, то есть аналог jshint, но продвинутый и специальный для react. Поэтомк лучше не ставить jshint сюда
Ладно, еще раз говорю все это будет разбираться, но позже
Запускаем проект:
npm start

У нас открывается дефолтный браузер и видим просто иконку с ссылкой не документацию. Можем ее в принципе удалить в app.js
А можно вообще пустую страницу оставить.

Заходим в консоль разработчика и видим, что нам предлагают установить плагин для браузера, чтобы у нас был лучше опыт
Это спейциальны раздел с компонентами для реакта, про которые я говорил, поэтому не жалуемся и идем скачивать

Вот так вот. Это можно сказать было вступление. Теперь смотрите файлы, там буду все разъяснять

А вот нихуя. React такая жопная штука, что нужно регулярно вспоминать всякую херь, которую разрабы нагородили
Короче, снизу буду кратко или некратко расписывать те вещи, с которыми могут быть осложнения и недопонимания

Структура файлов в react:

Итак, помним. public нам почти не нужен. Можем подключить в index.html все что нужно и забыть
src. Здесь тоже кроме index.js и папки с компонентами почти все ненунжно. Папку с компонентами разумеется делаем
Потом в этой папке делаем другие папки (их кол-во зависит от того, сколько вы посчитаете нужно сделать компонентов)
И в каждую папку запихиваем js и css файл с правильеым названием компонента, чтобы понятнее было.
Разумеется не забываем в каждый js файл импортировать css файл и другое по надобности

Общие правила:

Компоненты пишутся с большой буквы (потому что иначе react будет воспринимать их как обычные функции или классы)
Компоненты бывают двух типов функциональные и классовые (отличие в том, что в функциональные нельзя прописывать состояния, он можно с хуки)
В верстку можем поместить все, кроме объектов и функции, которые пишутся в несколько строк. Помещая массив, он конкатенируется
Всегда нужно закрывать теги, даже если они самозакрываюшиеся
Когда мы прописываем аттрибуты из реакта, то используем camelCase
Когда хотим приписать класс, то используем в аттрибуте className="'some class"
...

Свойства компонентов:

Итак, представим, что мы делаем карточку с товаром (ну то есть там есть цена, название, картинка, производитель и тд тп)
Собственно это и есть компонент. Мы сделали верстку для этой карточки, но нам ее нужно заполнить как раз этими данными, которые я в примере на строку выше указывал
Так вот, в наш компонент вводится как раз props. Так называется свойство в react
Если это функциональный компонент, то просто вводим аттрибут props, если классовый, то создаем в классе constructor, который наследует props (То есть пишите super(props))
Вот для наглядности:
constructor(props) {
    super(props);
}
Что же за props такой? Это по факту объект, в который мы запихиваем всю инфу или значения, которые нам нужны для компонента. Например, эти данные из сервака будут приходить
Сразу для тупых отвечу на вопрос нафиг нам это нужно. Нужно это, чтобы мы прописали одну структуру/верстку и использовали ее хоть тыщу раз, просто с разными значениями
Опять же возвращаемся к примеру с карточкой товара. Название, цену и так далее мы будем передавать props объектом
Тогда вопрос как нам заполнять этот компонент?
А заполняем мы его атрибутами в теге компонента. То есть пишем любое название и значение. Именно таким способом все будет передаваться в объект props
Тажке, можем деструктурирувать этот объект и сразу передавать в аргументы функции названия. Там name например или price. Подробный пример смотрите в app.js
Главное правило свойств в том, что они не изменяемы и идут только на чтение. ЧТобы изменить свойство компонента, нужно как раз весть этот компонент перерисовывать
А вот состояния, про которые чуть позже, как раз могут изменяться динамически без проблем
Передать в props можно все что угодно, даже объекты, которые опять например пришли с датабазы. Но помним, что вставлять целый объект мы не можем, а только его значение, поэтому необходимо прописать, что получаем мы именно значение переданного объекта
Можно также простые функции, тогда помним, что их нужно вызывать

Алгоритм согласования:

Значит это можно так сказать одно из правил react. Но его можно и не придерживаться. Если же вы не будете его придерживаться, то просто вы не будете использовать оптимизацию react полностью
В чем же дело и почему лучше этот алгоритм использовать. Дело в том, что когда мы работаем со списками чего либо (компонентов или элементов) списки этих элементов или компонентов может изменяться
Давайте в пример опять возьмем пример с карточками товаров. Итак, к нам пришел json файл, в котором идут объекты и  у кажлого объекта одни и те же ключи, но разные значения.
Мы это все передаем пропсом и получаем нужные карточки на странице. Супер. Но что если мы хотим добавить карточку или это делает пользователь? Тогда карточка попадает в список
А как мы помним, react переделывает только те элементы, которые нужно. Напомню, что реакт сохраняет копию render нужного компонента и сравнивает с другой измененной и в итоге изменяет только нужное
Так вот, при списке компонентов карточек он может запнуться, подумать что все идет в другом порядке и переделывать все карточки заново, чтобы это избежать, нужно добавить каждому компоненту значение key
Это значение key изначально идет в свойстве props (Ну то есть в объекте props) и нам остается тольео дать этому key значение. Задаем его как и всегда атрибутом (key={id})
id этот можем сами задавать, но тогда логично нужно и новым тоже давать id или получать с базы данных, но главное когда у вас идет список однинаковых компонентов обязательно давать key, чтобы использовать потенциал react по максимуму
Тажке может быть такое что с бекенда не пришли эти id, тогда можем использовать индекс элементов (который в методе data.map() например есть), но тогда у нас эти элементы, не должны меняться по очередности иначе все по пизде пойдет
Вот так как-то.

Состояние компонента:

Итак, как мы понимаем на странице существуют не только статические элементы,но и динамические, которые изменяются при клике например. Возьмем счетчик. Когда мы нажимвем, цифорка изменяется
Ну или слайдер давайте возьмем. Он тоже динамически изменятеся. И у таких вот элементов, нам нужно отслеживать какие-то значения. У счетчика это текущая цифра, которую он показывает на экране
У слайдов это текущий слайд и так далее. Так вот такие значения называются состоянием компонента
Итак, приступим у написанию. Вообще в ванильном react состояния можно прописывать только в классовых коспонентах, но с react hooks можно и в функциональных прописывать
Пока будем делать это только в классовых, потому что потому. 
Щас я вставлю код в ткустовый файл, надеюсь все ок выйдет

class WhoAmI2 extends Component{ 
  constructor (props) { //Так прописываются свойства классового компонента. От component приходит объект props, в котором мы пописали значения и мы его наследуем в кострукторе. Хотя как я и раньше говорил этот объект создается автоматически, поэтому если у нас только свойства нжно пережать в классовом компоненте, то constructor можно не прописывать
    super(props);
    this.state = { //Это как раз идет состояние компонента, то есть то, что будет изменяться. Оно тоже по умолчанию идет от component, поэтому просто обращаемся у нему
      years: 27, здесь пишем все что угодно. ну почти все разумеется
    }
  }

  nextYear = () => {
    console.log('+');
    this.setState({ //Напрямую изменять состояние мы не можем. Ну потому что react правило такое. Для этого используем метод setState. То есть только через этот метод изменяем state
      years: this.state.years + 1 //В этом методе прописываем объект, который мы до этого уже писали в конструкторе. Ну и собственно пишем что мы изменяем то
    })
  }
  nextYear = () => { //Из логики этого метода мы можем понять, что он просто обновляет значение того или иного состояния. Но этот код асихронный, поэтому может возникнуть, что при слишком частом выполнении этого метода, он будет опираться на значение. которое еще не обновилось
    this.setState(state => ({ //Ну например, слишком часто мы на счетчик кликаем и не успевает записать значение в state. Для избежания используем колбек функцию. В аргументе передается сам state (this.state)
        years: state.years + 1 //Потом нужно еще раз скобки приписать. Тем самым мы говорим, что это все ретурнится, ну и затем само действие с состоянием
    }))
  }
  commitInputChanges = (e, color) => { функции, которые вызываем в атрибутах тегов прописываем пока там. То есть стрелочную функцию
    console.log(color)
    this.setState({ //Кстати, когда мы запускаем setState, то функция render запускается заново и чтобы быстрее render отрабатывал нужно прописывать key
      position: e.target.value //Но react просто сохраняет старое значение и сравнивает его с новым и изменяет только нужное
    })
  }

  render() {
    const {name, surname, link} = this.props;
    const {position, years} = this.state;
    return (
      <div>
        <button onClick={this.nextYear}>click to next year</button>
        <h1>My name is: {name}, Surname is: {surname}, age is: {years}, Position is: {position}</h1>
        <a href={link}>My profile</a>
        <span>
          <p>Введите должность</p>
          <input type="text" onChange={(e) => this.commitInputChanges(e , 'somecolor')}/> {/*Также если нужно передать какие-то аргументы, то оборачиваем в стрелочную функцию и указываем их в функции*/}
      </span>
      </div>
    )
  }
}

Подводя итоги, давайте еще раз пройдемся по правилам для состояний.
Во-первых, состояния можно прописывать только в классовых компонентах если не используем хуки
Во-вторых, напрямую не можем изменять значение состояний. Используем setState()
В-третьих, setState у нас идет асихронно, поэтому внутри мутода можно прописать колбек функцию с return


События в react:

Итак, маслята. События в react вызываются в атрибутах как и значения props
Например (onClick={someToDo()})
Разумеется можно задавать не только onCLick но и много других событий, даже делать свои события
Их намного больше чем в нативном скрипте, поэтомк вот документация по всем:
https://ru.reactjs.org/docs/events.html
Многие из них работают абсолютно одинаково, но стоит использовать, которые чаще используют
Так вот, используем как обычный атрибут, туда передаем переменную со стрелочной функцией. Все просто

