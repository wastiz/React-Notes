Ну вот мы и дошли до react. Ухуууу.
В общем материала настолько будет много, что я решил его вынести в отдельную папку с репозиторием 
Также подумываю перенести все конспекты в notion, чтобы поцветастее было, да понятнее и удобнее. Но это как нибудь потом

Итак, начнем. React что щас, что и дальше будет популярным и постоянно всплывать в вакансиях. Как и говорилось ранее React
это целая среда и экосистема разработки у которой даже есть свои фреймворки и библиотеки. То есть у библиотеки есть свои библиотеки
ВОт настолько все зашло. 
React обычно предназначен для создания одностраничных приложений. То есть когда только какие-то част сайта обновляются, но не целая страница
Примепрами singlepage app является gmail instagram facebook. 
Основными принципами react или лучше сказать философией react является декларативность. То есть когда вы задаете просто конечную цель с результатом,
а не прописываете шаги к ней. Также создание своих компонентов. То есть браузеру придется не одно огромное дом дерево обрабатывать, где у каждого элемента по тысячи свойств,
а всего лишь скромные, ну или не скромные компоненты, созданные react и вами. Ну и что еще хочу выделить из принципов, так это то что эти компоненты будет легко использовать
повторно, хоть в других проектах.

Итак, переходим к подключению. Во-первых просто добавить реакт как например jquery или bootstrap не получится. Надо создаватьдля этого отдельный проект
Во-вторых, react уже имеет в себе некий webpack, который будет объединять модули, а также babel, который выступает в роли кроссбраузерности и компилятора.
Так как же мать его уже приступить к работе?
Щас все будет, не ссыте. Чтобы не создавать тысячу папок, за вас уже сделали готовую сборку для старта проекта

Запускаем эту команду:
npx create-react-app my-app

Когда все утсановится, вы увидите папку с my app и вам предложат перейти в эту папку, поэтомк не будем спорить и сделаем это
прописываем:
cd my-app

Теперь мы видим, что по путям мы зашли в папку. Также нам предлагают запустить это приложение, но щас пройдемся по папкам
Итак, в папке src мы видим index.js Помним, что это самый главный файл, то есть в этот файл все импортируется и именно этот файл будет обрабатывать браузер
Также, видим и другие всякие папки. Интуитивно можно догадаться, но в дальнейшем все разберем
Переходим в папку public. Там находятся все файлы, которые мы не будем особо трогать. Например, мы видим index.html. Логично что именно он будет отображаться. Щас в нем прописаны теги, чтобы при запуске у нас не было пустое окно
Также видим div с id='root'. Именно туда будет все рендерится
Еще если мы перейдем в package-json, то увидим все библиотеки, которые подрублены. Да, по факту мы щас не только react установили. Но не волнуйтесь, скоро со всем разберемся
Так вот, там мы можем увидеть eslint, то есть аналог jshint, но продвинутый и специальный для react. Поэтомк лучше не ставить jshint сюда
Ладно, еще раз говорю все это будет разбираться, но позже
Запускаем проект:
npm start

У нас открывается дефолтный браузер и видим просто иконку с ссылкой не документацию. Можем ее в принципе удалить в app.js
А можно вообще пустую страницу оставить.

Заходим в консоль разработчика и видим, что нам предлагают установить плагин для браузера, чтобы у нас был лучше опыт
Это спейциальны раздел с компонентами для реакта, про которые я говорил, поэтому не жалуемся и идем скачивать

Вот так вот. Это можно сказать было вступление. Теперь смотрите файлы, там буду все разъяснять

А вот нихуя. React такая жопная штука, что нужно регулярно вспоминать всякую херь, которую разрабы нагородили
Короче, снизу буду кратко или некратко расписывать те вещи, с которыми могут быть осложнения и недопонимания

Структура файлов в react:

Итак, помним. public нам почти не нужен. Можем подключить в index.html все что нужно и забыть
src. Здесь тоже кроме index.js и папки с компонентами почти все ненунжно. Папку с компонентами разумеется делаем
Потом в этой папке делаем другие папки (их кол-во зависит от того, сколько вы посчитаете нужно сделать компонентов)
И в каждую папку запихиваем js и css файл с правильеым названием компонента, чтобы понятнее было.
Разумеется не забываем в каждый js файл импортировать css файл и другое по надобности

Общие правила:

Компоненты пишутся с большой буквы (потому что иначе react будет воспринимать их как обычные функции или классы)
Компоненты бывают двух типов функциональные и классовые (отличие в том, что в функциональные нельзя прописывать состояния, он можно с хуки)
В верстку можем поместить все, кроме объектов и функции, которые пишутся в несколько строк. Помещая массив, он конкатенируется
Всегда нужно закрывать теги, даже если они самозакрываюшиеся
Когда мы прописываем аттрибуты из реакта, то используем camelCase
Когда хотим приписать класс, то используем в аттрибуте className="'some class"
...

По поводу картинок в react:
Чтобы использовать скачанные картинкиЮ иконки и тд тп, лучшим вариантом будет создать отдельную папку или папки с картинками в src.
ЧТобы использовать от туда картинки в компоненте мы используем 
import anyVariable from ../../img/anyPicture.png
Вот типо такого ток используем нормальные ссылки
И когда мы создали такую переменную, мы берем и используем в верстке как и другие переменные
<img src={anyVariable} alt="no image"/>

Свойства компонентов:

Итак, представим, что мы делаем карточку с товаром (ну то есть там есть цена, название, картинка, производитель и тд тп)
Собственно это и есть компонент. Мы сделали верстку для этой карточки, но нам ее нужно заполнить как раз этими данными, которые я в примере на строку выше указывал
Так вот, в наш компонент вводится как раз props. Так называется свойство в react
Если это функциональный компонент, то просто вводим аттрибут props, если классовый, то создаем в классе constructor, который наследует props (То есть пишите super(props))
Вот для наглядности:
constructor(props) {
    super(props);
}
Что же за props такой? Это по факту объект, в который мы запихиваем всю инфу или значения, которые нам нужны для компонента. Например, эти данные из сервака будут приходить
Сразу для тупых отвечу на вопрос нафиг нам это нужно. Нужно это, чтобы мы прописали одну структуру/верстку и использовали ее хоть тыщу раз, просто с разными значениями
Опять же возвращаемся к примеру с карточкой товара. Название, цену и так далее мы будем передавать props объектом
Тогда вопрос как нам заполнять этот компонент?
А заполняем мы его атрибутами в теге компонента. То есть пишем любое название и значение. Именно таким способом все будет передаваться в объект props
Тажке, можем деструктурирувать этот объект и сразу передавать в аргументы функции названия. Там name например или price. Подробный пример смотрите в app.js
Главное правило свойств в том, что они не изменяемы и идут только на чтение. ЧТобы изменить свойство компонента, нужно как раз весть этот компонент перерисовывать
А вот состояния, про которые чуть позже, как раз могут изменяться динамически без проблем
Передать в props можно все что угодно, даже объекты, которые опять например пришли с датабазы. Но помним, что вставлять целый объект мы не можем, а только его значение, поэтому необходимо прописать, что получаем мы именно значение переданного объекта
Можно также простые функции, тогда помним, что их нужно вызывать

Алгоритм согласования:

Значит это можно так сказать одно из правил react. Но его можно и не придерживаться. Если же вы не будете его придерживаться, то просто вы не будете использовать оптимизацию react полностью
В чем же дело и почему лучше этот алгоритм использовать. Дело в том, что когда мы работаем со списками чего либо (компонентов или элементов) списки этих элементов или компонентов может изменяться
Давайте в пример опять возьмем пример с карточками товаров. Итак, к нам пришел json файл, в котором идут объекты и  у кажлого объекта одни и те же ключи, но разные значения.
Мы это все передаем пропсом и получаем нужные карточки на странице. Супер. Но что если мы хотим добавить карточку или это делает пользователь? Тогда карточка попадает в список
А как мы помним, react переделывает только те элементы, которые нужно. Напомню, что реакт сохраняет копию render нужного компонента и сравнивает с другой измененной и в итоге изменяет только нужное
Так вот, при списке компонентов карточек он может запнуться, подумать что все идет в другом порядке и переделывать все карточки заново, чтобы это избежать, нужно добавить каждому компоненту значение key
Это значение key изначально идет в свойстве props (Ну то есть в объекте props) и нам остается тольео дать этому key значение. Задаем его как и всегда атрибутом (key={id})
id этот можем сами задавать, но тогда логично нужно и новым тоже давать id или получать с базы данных, но главное когда у вас идет список однинаковых компонентов обязательно давать key, чтобы использовать потенциал react по максимуму
Тажке может быть такое что с бекенда не пришли эти id, тогда можем использовать индекс элементов (который в методе data.map() например есть), но тогда у нас эти элементы, не должны меняться по очередности иначе все по пизде пойдет
Вот так как-то.

Состояние компонента:

Итак, как мы понимаем на странице существуют не только статические элементы,но и динамические, которые изменяются при клике например. Возьмем счетчик. Когда мы нажимвем, цифорка изменяется
Ну или слайдер давайте возьмем. Он тоже динамически изменятеся. И у таких вот элементов, нам нужно отслеживать какие-то значения. У счетчика это текущая цифра, которую он показывает на экране
У слайдов это текущий слайд и так далее. Так вот такие значения называются состоянием компонента
Итак, приступим у написанию. Вообще в ванильном react состояния можно прописывать только в классовых коспонентах, но с react hooks можно и в функциональных прописывать
Пока будем делать это только в классовых, потому что потому. 
Щас я вставлю код в ткустовый файл, надеюсь все ок выйдет

class WhoAmI2 extends Component{ 
  constructor (props) { //Так прописываются свойства классового компонента. От component приходит объект props, в котором мы пописали значения и мы его наследуем в кострукторе. Хотя как я и раньше говорил этот объект создается автоматически, поэтому если у нас только свойства нжно пережать в классовом компоненте, то constructor можно не прописывать
    super(props);
    this.state = { //Это как раз идет состояние компонента, то есть то, что будет изменяться. Оно тоже по умолчанию идет от component, поэтому просто обращаемся у нему
      years: 27, здесь пишем все что угодно. ну почти все разумеется
    }
  }

  nextYear = () => {
    console.log('+');
    this.setState({ //Напрямую изменять состояние мы не можем. Ну потому что react правило такое. Для этого используем метод setState. То есть только через этот метод изменяем state
      years: this.state.years + 1 //В этом методе прописываем объект, который мы до этого уже писали в конструкторе. Ну и собственно пишем что мы изменяем то
    })
  }
  nextYear = () => { //Из логики этого метода мы можем понять, что он просто обновляет значение того или иного состояния. Но этот код асихронный, поэтому может возникнуть, что при слишком частом выполнении этого метода, он будет опираться на значение. которое еще не обновилось
    this.setState(state => ({ //Ну например, слишком часто мы на счетчик кликаем и не успевает записать значение в state. Для избежания используем колбек функцию. В аргументе передается сам state (this.state)
        years: state.years + 1 //Потом нужно еще раз скобки приписать. Тем самым мы говорим, что это все ретурнится, ну и затем само действие с состоянием
    })
  }
  commitInputChanges = (e, color) => { функции, которые вызываем в атрибутах тегов прописываем пока там. То есть стрелочную функцию
    console.log(color)
    this.setState({ //Кстати, когда мы запускаем setState, то функция render запускается заново и чтобы быстрее render отрабатывал нужно прописывать key
      position: e.target.value //Но react просто сохраняет старое значение и сравнивает его с новым и изменяет только нужное
    })
  }

  render() {
    const {name, surname, link} = this.props;
    const {position, years} = this.state;
    return (
      <div>
        <button onClick={this.nextYear}>click to next year</button>
        <h1>My name is: {name}, Surname is: {surname}, age is: {years}, Position is: {position}</h1>
        <a href={link}>My profile</a>
        <span>
          <p>Введите должность</p>
          <input type="text" onChange={(e) => this.commitInputChanges(e , 'somecolor')}/> {/*Также если нужно передать какие-то аргументы, то оборачиваем в стрелочную функцию и указываем их в функции*/}
      </span>
      </div>
    )
  }
}

Подводя итоги, давайте еще раз пройдемся по правилам для состояний.
Во-первых, состояния можно прописывать только в классовых компонентах если не используем хуки
Во-вторых, напрямую не можем изменять значение состояний. Используем setState()
В-третьих, setState у нас идет асихронно, поэтому внутри мутода можно прописать колбек функцию с return


События в react:

Итак, маслята. События в react вызываются в атрибутах как и значения props
Например (onClick={someToDo()})
Разумеется можно задавать не только onCLick но и много других событий, даже делать свои события
Их намного больше чем в нативном скрипте, поэтомк вот документация по всем:
https://ru.reactjs.org/docs/events.html
Многие из них работают абсолютно одинаково, но стоит использовать, которые чаще используют
Так вот, используем как обычный атрибут, туда передаем переменную со стрелочной функцией. Все просто

Также можем создавать собственные события. И щас вы такие: А это как?
Смотрите, в props мы можем передать (то есть в аргументах компонента написать) какую то функцию, которая будет передаваться в компонент в видк пропса и потом существующими событиями вызывать ее
То есть по факту мы просто передаем функции из компонента в компонент. В проекте это испольщуется, чтобы потом брать данные из data объекта.

Иммутабельность объекта, состояния и так далее:
Эта иммутабельность заключается в том, чтобы при появлении чего либо (То есть это может быть объект, состояние, свойство и так далее) он напрямую не изменялся.
Но как тогда быть если хотим например удалить тот же какой-нибудь элемент объекта. Для того чтобы этот объект оставался иммутабельным, нам нужно создать его клон, внести туда изменения и потом использовать этот клон в своих нуждах
Разумеется старый объект остается неизмененным. 
А зачем? Ну у этого подхода несколько плюсов, например, для методов сравнения, или каких то тестов. Да конечно будет расходоваться чуть больше памяти, но эт не критично, зато вам самим удобнее будет
Вообще иммутабельность не только к react относится. В ванильном js тоже применяют этот подход. Но в react это желательнее всего делать чтобы баги не выскакивали и react быстрее работал. Так скажем по его философии

Подъем состояния:
Подъем состояния это когда мы переносим какие-то состояния в другой компонент, который находится по иерархии выше. В нашем случае, это app.js
Делается это просто. Почти также как с props
Сначала создаем state куда мы хотим передать другой state, потом там же делаем метод, который принимает какой-то аргумент и внутри метода
задаем новый state (пишем setState) в который передаем аргумент. Ну и собственно вызываем этот метод в компоненте

React фрагменты:
Как мы помним по правилу jsx нам нужно верстку оборачивать в один родительский элемент. Чаще всего это div. Но что если он нам в верстке будет только мешать?
Мы можем от него избавиться react фрагментом. Для этого во первых нам нужно вытащить fragment из библтотеки
import {Fragment} from 'react';
И теперь в верстку вместо div пишем <Fragment>Тут наша верстка</Fragment>
Но вы не поверите. Можно просто вместо этого тега оставить пустой тег и будет тоже самое.
Отличаются эти синтаксисы в том, что если нам нужно задать какие-то атрибуты оборачиваемому тегу, то нужно использовать именно первый вариант
Например, если мы работаем со списками и нам нужно прописать key=""

Про стили в react:

Инлайн стили. Как мы знаем инлайн стили лучшене использовать вообще, так как их можно легко переписать, то есть каскадность у этих стилей самая низкая
Но иногда все таки надо это сделать. например, мы хотим добавить динамически добавить цвет, но прописывать целый класс для этого глупо
Для этого тогда прописываем в атрибуте 
style={{fontSize: '40px'}}
Как мы видим style принимает в себя объект, в который мы записываем camelCase свойство и string значение
Только помним тогда, что вендорные префиксы прописываются вручную. Это приставки, которые ставятся перед свойствами, чтобы использовать фичи браузеров (всякие webkit и прочее)

Чтобы использовать препроцессоры sass/scss (less пока что в react не поддерживается), нужно установить npm сначала нужный
npm i sass --save
И все тперь создаем scss или sass файлы
Но помним про одну особенность сборщика модулей в react, а именно то что он не собирает все файлы в оин большой, а поэтому если вы хотите использовать переменные scss, то импортируем их во все файлы

css in js:
Да, и такая дичь есть. Точнее технология. Это не фишка react. Просто маленький фреймаворк. Использовать ваще не обязателно, но мы рассмотрим ее
npm i --save styled-components
Собственно называется он styled components
Для того чтобы что-то да стилизовать мы берем styled.div (в данном примере используется div, а так люьой другой тег можно), затем раскрываем бектики и в них пишем все что душе угодно
ЧТобы переписать какой-то стиль элемента, то создаем новую переменную и в нее прописываем метод styled(), в аргумент пишем эелемент, который переамсываем
Еще есть возможность переписать сам тег, то есть его семантику. Для этого в атрибутах компонента пишем as='' и внутри него новый тег. Тем самым button может превратиться например в h2
Еще этот фреймаворк поддерживает вложенность как scss. Мы просто также прописываем дальше элементы и стилизуем их
Разумеется это невсе фичи этого вреймворка. Если надо то как всегда идем в документацию. На самом деле этот фреймворк вообще не часто используют в проектах, так как у него иного минусов
Ну раз когда то да используют, то значит есть и плюсы

React bootstrap:
Итак, по поводу bootstrap. Смотрите, еслм=и мы будем использовать обычный bootstrap, то мы также можемпрописывать классы, какие-то элементы брать и все остальные фичи использовать.
Нам нужно делать отдельные компоненты, которые будут содержать этот bootstrap код, экспортировать, импортировать и тому подобнок
Но, есть react bootstrap, в котором за нас уже сделали готовые компонеты, в которых своя логика и никакого велосипеда придумывать не надо
npm install react-bootstrap@next bootstrap@5.1.0
Версии разумеется могут обновляться
Кароче, я также как с предыдущей библиотекуой могу распинаться. Тут вот так вот, там вот так прописываем. Но во первых конспект по bootstrap уже есть и если вы хотя бы чкть чкть понимаете react, то в документации проблем у вас вооще не будет
Поэтому вот вам ссылка:
https://react-bootstrap.github.io/components/alerts
Читайте и практикуйте

material ui:
Тоже прикольная библиотека. Вот документация
https://mui.com/material-ui/getting-started/overview/

МОДУЛЬ 2. СРЕДНИЙ УРОВЕНЬ

Чтож, начнем новый модуль с повторения api. API - application programming interface
По факту это тот же написанный за вас код, который можем использовать для своих нужд. То есть смысл такой же у=как и у фреймворков
То есть можео сказать что подключение фреймворков через cdn ссылку можно назвать api. Нууу... почти
api это больше все таки набор функций для взаимодействия с базой данных или технологиям девайса
Например, если в нашем приложении должен исаользовать блютуз, то мы подключаем апи устройства в котором есть блютуз и сипользуем от туда функции
В новом проекте мы будеи использовать marvel api.
Это просто база данных, в окторой нажоится информация о марвел персонажах комиксах и тд тп
И соответсвенно сайт мы бкдеи делать под эту тематику используя инфу только из этого api










